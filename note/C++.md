<!-- GFM-TOC -->
* [C++基础知识](#C++基础知识)

<!-- GFM-TOC -->

# C++基础知识

## 模块连接（阿里试题）
### 静态连接
> 1. 由编译器完成
> 2. 被掉函数体拷贝到目标语言程序中，可能存在多份拷贝
> 3. 装载速度快、运行速度快
> 4. 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题
### 动态连接
> 1. 由操作系统完成
> 2. 被调用函数体不随着装入内存，只有被调用才会从外存装入内存，同一个函数不会出出现多个副本
> 3. 运行速度慢
> 4. 更加节省内存并减少页面交换
> 5. DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

## 函数绑定
> 绑定是指函数入口地址与函数调用相联系的过程，计算出被调用函数入口地址，然后将改地址防到函数调用指令的地址码部分
### 静态绑定与动态绑定
> 静态绑定是由编译器或操作系统在装入程序时计算的地址，是执行完之前；动态绑定是执行过程中由程序自身计算函数入口地址。
>
> **静态绑定或动态绑定与静态连接或动态连接没有关系**

## 变量初始化
> 1. C语言不进行缺省初始化；C++会缺省初始化，C++变量可以用任意表达式初始化，但是表达式中的过程不展示。例如`sizeof(printf("abc") + 2)`，不会打印出`abc`。
> 2. 对于全局变量，初始值由编译器生成的开工函数在运行时得到，C++会自动提供缺省的析构函数和构造函数。
> 3. 初始化顺序与变量定义顺序有关，与模块连接顺序有关

## 指针数组与数组指针
### 指针数组
> 1. `char *arr[2] = {"hello", "world"}` `arr`是一个指针数组，有四个元素，每个元素是一个`char *`类型的指针，大小为`sizeof(char *) * 2`字节。
### 数组指针
> 2. `char (*pa)[4]`是数组指针，`pa`指向`char [4]`的数组。
>
> **需要注意的是：`char a[4]`中，不能够直接`pa = a`，因为类型不同，需要为`pa = &a`，`pa + 1`相当于`a + 4`，意思就是`pa`要指向一块`char [4]`的地址的首址**
>
> **不能直接向类型不定`void`的存储单元赋值，一定要进行强制转换后才能赋值**

## const
> 1. `const in *p = int const *p`，表示指向的内容是只读的，指针指针指向可以变化
> 2. `int * const p`表示指针是只读的，不可以变换，但是指向的内容是可变的
>
> **可以用`const`和`volatile`（挥发变量）同时修饰对象**

## 引用参数
> 1. 引用参数需要左值表达式，例如`++i`，右值表达式`i++`或者`i + 1`时会生成匿名变量，匿名变量的值由表达式决定，会由匿名变量带回结果
```c++
int inc (int &x) {
      return x++;   //注意这里返回x,再++
}
int i = 2, j = 1;
int main(void)
{
      j = inc(++i);   //i 带回结果,i = 4, j = 3
      j = inc(i++);   //生成匿名变量x = 4，匿名变量带回结果，i = 5, j = 4
}
```
> 2. 引用变量必须用左值表达式初始化
```c++
int &k = j++;   //错误
```
> 3. 引用数组写法
```c++
int t[6];
int (&u)[6] = t;  //正确
int &u = t;       //错误，不能用int [6]来初始化int &类型
```
>
> **数组元素不能为引用类型，位段也不能为引用类型**

## 重载
> **1. 全局`main`函数、析构函数不会有重载函数。但是静态`main`函数可以由重载函数**
> 
> **2. 重载函数只与函数参数有关，与函数的返回类型无关。-如果函数参数和类型完全相同，但是返回类型不同也不能作为重载函数**
