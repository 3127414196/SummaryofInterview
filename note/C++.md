<!-- GFM-TOC -->
* [C++基础知识](#C++基础知识)
* [做题总结](#做题总结)
<!-- GFM-TOC -->

# C++基础知识

## 模块连接（阿里试题）
### 静态连接
> 1. 由编译器完成
> 2. 被掉函数体拷贝到目标语言程序中，可能存在多份拷贝
> 3. 装载速度快、运行速度快
> 4. 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题
### 动态连接
> 1. 由操作系统完成
> 2. 被调用函数体不随着装入内存，只有被调用才会从外存装入内存，同一个函数不会出出现多个副本
> 3. 运行速度慢
> 4. 更加节省内存并减少页面交换
> 5. DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

## 函数绑定
> 绑定是指函数入口地址与函数调用相联系的过程，计算出被调用函数入口地址，然后将改地址防到函数调用指令的地址码部分
### 静态绑定与动态绑定
> 静态绑定是由编译器或操作系统在装入程序时计算的地址，是执行完之前；动态绑定是执行过程中由程序自身计算函数入口地址。
>
> **静态绑定或动态绑定与静态连接或动态连接没有关系**

## 变量初始化
> 1. C语言不进行缺省初始化；C++会缺省初始化，C++变量可以用任意表达式初始化，但是表达式中的过程不展示。例如`sizeof(printf("abc") + 2)`，不会打印出`abc`。
> 2. 对于全局变量，初始值由编译器生成的开工函数在运行时得到，C++会自动提供缺省的析构函数和构造函数。
> 3. 初始化顺序与变量定义顺序有关，与模块连接顺序有关

## 指针数组与数组指针
### 指针数组
> 1. `char *arr[2] = {"hello", "world"}` `arr`是一个指针数组，有四个元素，每个元素是一个`char *`类型的指针，大小为`sizeof(char *) * 2`字节。
### 数组指针
> 2. `char (*pa)[4]`是数组指针，`pa`指向`char [4]`的数组。
>
> **需要注意的是：`char a[4]`中，不能够直接`pa = a`，因为类型不同，需要为`pa = &a`，`pa + 1`相当于`a + 4`，意思就是`pa`要指向一块`char [4]`的地址的首址**
>
> **不能直接向类型不定`void`的存储单元赋值，一定要进行强制转换后才能赋值**

## const
> 1. `const in *p = int const *p`，表示指向的内容是只读的，指针指针指向可以变化
> 2. `int * const p`表示指针是只读的，不可以变换，但是指向的内容是可变的
>
> **可以用`const`和`volatile`（挥发变量）同时修饰对象**

## 引用参数
> 1. 引用参数需要左值表达式，例如`++i`，右值表达式`i++`或者`i + 1`时会生成匿名变量，匿名变量的值由表达式决定，会由匿名变量带回结果
```c++
int inc (int &x) {
      return x++;   //注意这里返回x,再++
}
int i = 2, j = 1;
int main(void)
{
      j = inc(++i);   //i 带回结果,i = 4, j = 3
      j = inc(i++);   //生成匿名变量x = 4，匿名变量带回结果，i = 5, j = 4
}
```
> 2. 引用变量必须用左值表达式初始化
```c++
int &k = j++;   //错误
```
> 3. 引用数组写法
```c++
int t[6];
int (&u)[6] = t;  //正确
int &u = t;       //错误，不能用int [6]来初始化int &类型
```
> 4. 指针与引用的区别
  > 指针是对象，占据内存；引用是变量的别名，本身不占内存
  > `sizeof(引用)`得到的是所指对象的大小，`sizeof(指针)`得到的是指针本身大小
  > 引用必须初始化，指针不必
  > 引用初始化之后不能被改变，指针可以改变所指向的对象
  > 不存在指向空值的引用，但是存在指向指向空值的指针
  > 指针和引用的自增(++)运算意义不一样，引用++相当于引用的对象++
  > 引用是类型安全的，而指针不是（引用比指针多了类型检测）
  >
> **数组元素不能为引用类型，位段也不能为引用类型**

## 重载
> **1. 全局`main`函数、析构函数不会有重载函数。但是静态`main`函数可以由重载函数**
>
> **2. 重载函数只与函数参数有关，与函数的返回类型无关。-如果函数参数和类型完全相同，但是返回类型不同也不能作为重载函数**
> **不能重载的运算符：
> `sizeof` `::` `?:` '.' `.*`
> 只能通过成员函数进行重载
> `=` `()` `[]` `->`**

# 做题总结
> 1. 程序进行编译时不为形式参数分配存储空间。形式参数是指函数定义的时候里面的参数
> 2. 数值型常量有整型常量,实型常量,不论是整型常量还是实型常量都有正值和负值之分。在C语言的预编译处理中,可以用符号名代表一个常量,定义时不必指定常量类型。常量的定义就是常量是在程序运行过程中值不能够被改变的量。
```c++
const int num = 8;
int* p = (int* )&num;
*p = 10;            //num = 8, *p = 10
```
> 3. `abs`函数中返回值可能为正数，0，负数。返回负数的情况为`abs(0x80000000)`返回的仍然是`0x80000000`，因为负数比正数多1，所以最大的负数找不到对应的正数，所以返回本身。
> 4. 对于不同位机器变量占用位数

  类型|32位编译器(字节)|64位编译器(字节)
  -|-|-|
  char|1|1
  short int|2|2
  int|4|4
  unsigned int|4|4
  float|4|4
  double|8|8
  long|4|8
  long long|8|8
  unsigned long|4|8
  任意指针|4|8
> 5.
